// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MODEL_MY_MODEL_H_
#define FLATBUFFERS_GENERATED_MODEL_MY_MODEL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace my_model {

struct Tensor;
struct TensorBuilder;

struct Conv2DOptions;
struct Conv2DOptionsBuilder;

struct Operator;
struct OperatorBuilder;

struct SubGraph;
struct SubGraphBuilder;

struct Model;
struct ModelBuilder;

struct Tensor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4,
    VT_DATA = 6
  };
  const ::flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  const ::flatbuffers::Vector<float> *data() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  typedef Tensor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<float>> data) {
    fbb_.AddOffset(Tensor::VT_DATA, data);
  }
  explicit TensorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Tensor> CreateTensor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> data = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_shape(shape);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Tensor> CreateTensorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *shape = nullptr,
    const std::vector<float> *data = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  auto data__ = data ? _fbb.CreateVector<float>(*data) : 0;
  return my_model::CreateTensor(
      _fbb,
      shape__,
      data__);
}

struct Conv2DOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Conv2DOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATION_FUNCTION = 4,
    VT_PADDING = 6,
    VT_STRIDES = 8
  };
  const ::flatbuffers::String *activation_function() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACTIVATION_FUNCTION);
  }
  const ::flatbuffers::String *padding() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PADDING);
  }
  const ::flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACTIVATION_FUNCTION) &&
           verifier.VerifyString(activation_function()) &&
           VerifyOffset(verifier, VT_PADDING) &&
           verifier.VerifyString(padding()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           verifier.EndTable();
  }
};

struct Conv2DOptionsBuilder {
  typedef Conv2DOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_activation_function(::flatbuffers::Offset<::flatbuffers::String> activation_function) {
    fbb_.AddOffset(Conv2DOptions::VT_ACTIVATION_FUNCTION, activation_function);
  }
  void add_padding(::flatbuffers::Offset<::flatbuffers::String> padding) {
    fbb_.AddOffset(Conv2DOptions::VT_PADDING, padding);
  }
  void add_strides(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(Conv2DOptions::VT_STRIDES, strides);
  }
  explicit Conv2DOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Conv2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Conv2DOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> activation_function = 0,
    ::flatbuffers::Offset<::flatbuffers::String> padding = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> strides = 0) {
  Conv2DOptionsBuilder builder_(_fbb);
  builder_.add_strides(strides);
  builder_.add_padding(padding);
  builder_.add_activation_function(activation_function);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Conv2DOptions> CreateConv2DOptionsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *activation_function = nullptr,
    const char *padding = nullptr,
    const std::vector<int32_t> *strides = nullptr) {
  auto activation_function__ = activation_function ? _fbb.CreateString(activation_function) : 0;
  auto padding__ = padding ? _fbb.CreateString(padding) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  return my_model::CreateConv2DOptions(
      _fbb,
      activation_function__,
      padding__,
      strides__);
}

struct Operator FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OperatorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_INDEX = 4,
    VT_OP_NAME = 6,
    VT_WEIGHTS = 8,
    VT_BIAS = 10,
    VT_OUTPUTS = 12,
    VT_CONV_OPTIONS = 14
  };
  int32_t op_index() const {
    return GetField<int32_t>(VT_OP_INDEX, 0);
  }
  const ::flatbuffers::String *op_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OP_NAME);
  }
  const my_model::Tensor *weights() const {
    return GetPointer<const my_model::Tensor *>(VT_WEIGHTS);
  }
  const my_model::Tensor *bias() const {
    return GetPointer<const my_model::Tensor *>(VT_BIAS);
  }
  const ::flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<my_model::Conv2DOptions>> *conv_options() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<my_model::Conv2DOptions>> *>(VT_CONV_OPTIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OP_INDEX, 4) &&
           VerifyOffset(verifier, VT_OP_NAME) &&
           verifier.VerifyString(op_name()) &&
           VerifyOffset(verifier, VT_WEIGHTS) &&
           verifier.VerifyTable(weights()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyTable(bias()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_CONV_OPTIONS) &&
           verifier.VerifyVector(conv_options()) &&
           verifier.VerifyVectorOfTables(conv_options()) &&
           verifier.EndTable();
  }
};

struct OperatorBuilder {
  typedef Operator Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_index(int32_t op_index) {
    fbb_.AddElement<int32_t>(Operator::VT_OP_INDEX, op_index, 0);
  }
  void add_op_name(::flatbuffers::Offset<::flatbuffers::String> op_name) {
    fbb_.AddOffset(Operator::VT_OP_NAME, op_name);
  }
  void add_weights(::flatbuffers::Offset<my_model::Tensor> weights) {
    fbb_.AddOffset(Operator::VT_WEIGHTS, weights);
  }
  void add_bias(::flatbuffers::Offset<my_model::Tensor> bias) {
    fbb_.AddOffset(Operator::VT_BIAS, bias);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(Operator::VT_OUTPUTS, outputs);
  }
  void add_conv_options(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<my_model::Conv2DOptions>>> conv_options) {
    fbb_.AddOffset(Operator::VT_CONV_OPTIONS, conv_options);
  }
  explicit OperatorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Operator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Operator>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Operator> CreateOperator(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t op_index = 0,
    ::flatbuffers::Offset<::flatbuffers::String> op_name = 0,
    ::flatbuffers::Offset<my_model::Tensor> weights = 0,
    ::flatbuffers::Offset<my_model::Tensor> bias = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<my_model::Conv2DOptions>>> conv_options = 0) {
  OperatorBuilder builder_(_fbb);
  builder_.add_conv_options(conv_options);
  builder_.add_outputs(outputs);
  builder_.add_bias(bias);
  builder_.add_weights(weights);
  builder_.add_op_name(op_name);
  builder_.add_op_index(op_index);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Operator> CreateOperatorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t op_index = 0,
    const char *op_name = nullptr,
    ::flatbuffers::Offset<my_model::Tensor> weights = 0,
    ::flatbuffers::Offset<my_model::Tensor> bias = 0,
    const std::vector<int32_t> *outputs = nullptr,
    const std::vector<::flatbuffers::Offset<my_model::Conv2DOptions>> *conv_options = nullptr) {
  auto op_name__ = op_name ? _fbb.CreateString(op_name) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto conv_options__ = conv_options ? _fbb.CreateVector<::flatbuffers::Offset<my_model::Conv2DOptions>>(*conv_options) : 0;
  return my_model::CreateOperator(
      _fbb,
      op_index,
      op_name__,
      weights,
      bias,
      outputs__,
      conv_options__);
}

struct SubGraph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SubGraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBGRAPH_INDEX = 4,
    VT_OPERATORS = 6
  };
  int32_t subgraph_index() const {
    return GetField<int32_t>(VT_SUBGRAPH_INDEX, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<my_model::Operator>> *operators() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<my_model::Operator>> *>(VT_OPERATORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SUBGRAPH_INDEX, 4) &&
           VerifyOffset(verifier, VT_OPERATORS) &&
           verifier.VerifyVector(operators()) &&
           verifier.VerifyVectorOfTables(operators()) &&
           verifier.EndTable();
  }
};

struct SubGraphBuilder {
  typedef SubGraph Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_subgraph_index(int32_t subgraph_index) {
    fbb_.AddElement<int32_t>(SubGraph::VT_SUBGRAPH_INDEX, subgraph_index, 0);
  }
  void add_operators(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<my_model::Operator>>> operators) {
    fbb_.AddOffset(SubGraph::VT_OPERATORS, operators);
  }
  explicit SubGraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SubGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SubGraph>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SubGraph> CreateSubGraph(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t subgraph_index = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<my_model::Operator>>> operators = 0) {
  SubGraphBuilder builder_(_fbb);
  builder_.add_operators(operators);
  builder_.add_subgraph_index(subgraph_index);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SubGraph> CreateSubGraphDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t subgraph_index = 0,
    const std::vector<::flatbuffers::Offset<my_model::Operator>> *operators = nullptr) {
  auto operators__ = operators ? _fbb.CreateVector<::flatbuffers::Offset<my_model::Operator>>(*operators) : 0;
  return my_model::CreateSubGraph(
      _fbb,
      subgraph_index,
      operators__);
}

struct Model FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODEL_NAME = 4,
    VT_SUBGRAPHS = 6
  };
  const ::flatbuffers::String *model_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MODEL_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<my_model::SubGraph>> *subgraphs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<my_model::SubGraph>> *>(VT_SUBGRAPHS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODEL_NAME) &&
           verifier.VerifyString(model_name()) &&
           VerifyOffset(verifier, VT_SUBGRAPHS) &&
           verifier.VerifyVector(subgraphs()) &&
           verifier.VerifyVectorOfTables(subgraphs()) &&
           verifier.EndTable();
  }
};

struct ModelBuilder {
  typedef Model Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_model_name(::flatbuffers::Offset<::flatbuffers::String> model_name) {
    fbb_.AddOffset(Model::VT_MODEL_NAME, model_name);
  }
  void add_subgraphs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<my_model::SubGraph>>> subgraphs) {
    fbb_.AddOffset(Model::VT_SUBGRAPHS, subgraphs);
  }
  explicit ModelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Model> CreateModel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> model_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<my_model::SubGraph>>> subgraphs = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_subgraphs(subgraphs);
  builder_.add_model_name(model_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Model> CreateModelDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *model_name = nullptr,
    const std::vector<::flatbuffers::Offset<my_model::SubGraph>> *subgraphs = nullptr) {
  auto model_name__ = model_name ? _fbb.CreateString(model_name) : 0;
  auto subgraphs__ = subgraphs ? _fbb.CreateVector<::flatbuffers::Offset<my_model::SubGraph>>(*subgraphs) : 0;
  return my_model::CreateModel(
      _fbb,
      model_name__,
      subgraphs__);
}

inline const my_model::Model *GetModel(const void *buf) {
  return ::flatbuffers::GetRoot<my_model::Model>(buf);
}

inline const my_model::Model *GetSizePrefixedModel(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<my_model::Model>(buf);
}

inline bool VerifyModelBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<my_model::Model>(nullptr);
}

inline bool VerifySizePrefixedModelBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<my_model::Model>(nullptr);
}

inline void FinishModelBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<my_model::Model> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedModelBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<my_model::Model> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace my_model

#endif  // FLATBUFFERS_GENERATED_MODEL_MY_MODEL_H_
